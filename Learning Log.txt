to make Python have something similar to static type checking, use mypy

to use mypy with pysdl without getting a lot of warnings about missing types, 
i use the fully qualified namespace: import sdl2 and then use sdl2.SDL_Whatever, 
don't go from sdl2 import * then try to use SDL_Whatever. i will still have an 
error for the import statement; to fix this, make a mypy.ini file in root that 
suppresses the missing imports warning for this library specifically:

	[mypy-sdl2]
	ignore_missing_imports = True

--------------------------------------------------------------------------------

to implement an interface, use the abc class with abstract methods that simply 
call pass. overriding will be required in the classes which implement the 
interface.

accoding to mypy docs, unfortunately:
"Itâ€™s a common error to forget to implement an abstract method ... the class 
definition will not generate an error in this case, but any attempt to 
construct an instance will be flagged as an error."

use typing.Iterable[InterfaceType] rather than list[InterfaceType] otherwise 
mypy will complain about incompatible types

when using __init__, it wont be type checked unless you explicitly show the 
return type as -> None. you'll get an error "By default the bodies of untyped 
functions are not checked, consider using --check-untyped-defs". 
https://mypy.readthedocs.io/en/stable/common_issues.html shows this:

	class Bad:
	    def __init__(self):
	        self.value = "asdf"
	        1 + "asdf"  # No error!
	
	bad = Bad()
	bad.value + 1           # No error!
	reveal_type(bad)        # Revealed type is "__main__.Bad"
	reveal_type(bad.value)  # Revealed type is "Any"
	
	class Good:
	    def __init__(self) -> None:  # Explicitly return None
	        self.value = value

--------------------------------------------------------------------------------

i have had an issue where i need to cast to int right before passing values into 
an objects render call

	player = sdl2.SDL_Rect(int(self.x), self.y, self.w, self.h)

as opposed to casting earlier, which creates strange movement issues. not sure 
if this is ideal or not.

--------------------------------------------------------------------------------

"Parameterized generics cannot be used with class or instance checks"

iow: you can't do this:

for item in self.renderables:
	if isinstance(item, Iterable[IRenderable]):
		for subitem in item:
			subitem.render(self.renderer)
	elif type(item) == IRenderable:
		item.render(self.renderer)

you'd need to use isInstance on each subitem too to do a separate IRenderable 
check. but this is unnecessary because self.renderables is already typed anyway, 
so it will contain renderables.

--------------------------------------------------------------------------------

python getters and setters example
from https://realpython.com/python-getter-setter/

from datetime import date

class Employee:
    def __init__(self, name, birth_date):
        self.name = name
        self.birth_date = birth_date

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value.upper()

    @property
    def birth_date(self):
        return self._birth_date

    @birth_date.setter
    def birth_date(self, value):
        self._birth_date = date.fromisoformat(value)

i can also make my setters cast to the correct type for safety.
don't need to perform cast on getter because setter means data in class
will be guaranteed to be correct type anyway

--------------------------------------------------------------------------------

it's only SDL_Rect that i need to give integers, so i only need to cast the
inputs there. my classes can store whatever number type otherwise

update: not true. collision detection goes weird when mixing floats and ints

i fixed an issue with collision detection by updating the ball's position, 
along with the change in direction. without doing this, it seems to cause
the direction to flip back and forth repeatedly, causing weird movement

to change a game object's origin from topleft to midpoint, all i need to do is
perform a translation when rendering. i don't "actually" need to move the item
because the game logic only cares about consistency

--------------------------------------------------------------------------------

in python each object is automatically assigned an id at instantiation. this may
be used when dealing with game logic and you need to know which objects were
involved

--------------------------------------------------------------------------------

if i want to use Iterable[my_type] instead of list for static type checking
purposes, but later need to call a list method like .remove(), i can just
cast the iterable to a list and call .remove() on it.